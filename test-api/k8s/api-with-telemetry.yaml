apiVersion: v1
kind: ConfigMap
metadata:
  name: api-config
  namespace: test-api
data:
  DATABASE_URL: "postgresql://postgres:password123@postgres-service:5432/testdb"
  OTEL_EXPORTER_OTLP_ENDPOINT: "http://signoz-otel-collector.platform:4317"
  OTEL_RESOURCE_ATTRIBUTES: "service.name=test-api,service.version=1.0.0,environment=production"
  OTEL_SERVICE_NAME: "test-api"
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: test-api-telemetry
  namespace: test-api
  labels:
    app: test-api-telemetry
spec:
  replicas: 1
  selector:
    matchLabels:
      app: test-api-telemetry
  template:
    metadata:
      labels:
        app: test-api-telemetry
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/path: "/metrics"
        prometheus.io/port: "8000"
    spec:
      containers:
        - name: test-api-telemetry
          # Usando uma imagem pública com Python e OpenTelemetry
          image: python:3.11-slim
          command: ["/bin/bash"]
          args:
            - -c
            - |
              pip install fastapi uvicorn asyncpg opentelemetry-api opentelemetry-sdk opentelemetry-exporter-otlp opentelemetry-instrumentation-fastapi opentelemetry-instrumentation-asyncpg
              cat > /tmp/app.py << 'EOF'
              import os
              import asyncio
              import asyncpg
              from fastapi import FastAPI, HTTPException, Depends
              from pydantic import BaseModel
              from typing import List
              import uvicorn
              from opentelemetry import trace
              from opentelemetry.sdk.resources import Resource
              from opentelemetry.sdk.trace import TracerProvider
              from opentelemetry.sdk.trace.export import BatchSpanProcessor
              from opentelemetry.exporter.otlp.proto.grpc.trace_exporter import OTLPSpanExporter
              from opentelemetry.instrumentation.fastapi import FastAPIInstrumentor
              from opentelemetry.instrumentation.asyncpg import AsyncPGInstrumentor
              import logging

              # Configuração do OpenTelemetry
              resource = Resource.create({
                  "service.name": "test-api",
                  "service.version": "1.0.0",
                  "environment": "production"
              })

              # Tracing
              trace.set_tracer_provider(TracerProvider(resource=resource))
              tracer = trace.get_tracer(__name__)
              otlp_exporter_trace = OTLPSpanExporter(endpoint=os.getenv("OTEL_EXPORTER_OTLP_ENDPOINT", "http://localhost:4317"), insecure=True)
              span_processor = BatchSpanProcessor(otlp_exporter_trace)
              trace.get_tracer_provider().add_span_processor(span_processor)

              app = FastAPI(title="Test API with Telemetry", version="1.0.0")
              FastAPIInstrumentor.instrument_app(app)
              AsyncPGInstrumentor().instrument()

              DATABASE_URL = os.getenv("DATABASE_URL", "postgresql://user:password@localhost:5432/mydatabase")

              class UserBase(BaseModel):
                  name: str
                  email: str

              class UserCreate(UserBase):
                  pass

              class User(UserBase):
                  id: int

                  class Config:
                      from_attributes = True

              async def get_db_connection():
                  conn = None
                  try:
                      conn = await asyncpg.connect(DATABASE_URL)
                      yield conn
                  finally:
                      if conn:
                          await conn.close()

              @app.on_event("startup")
              async def startup_event():
                  logging.info("Starting up application...")
                  await connect_to_db()
                  logging.info("Application started.")

              async def connect_to_db():
                  retries = 5
                  for i in range(retries):
                      try:
                          conn = await asyncpg.connect(DATABASE_URL)
                          await conn.execute('''
                              CREATE TABLE IF NOT EXISTS users (
                                  id SERIAL PRIMARY KEY,
                                  name VARCHAR(100) NOT NULL,
                                  email VARCHAR(100) UNIQUE NOT NULL
                              )
                          ''')
                          await conn.close()
                          logging.info("Database connected and schema verified.")
                          return
                      except Exception as e:
                          logging.error(f"Attempt {i+1} to connect to database failed: {e}")
                          if i < retries - 1:
                              await asyncio.sleep(2 ** i)

              @app.get("/", summary="Health Check", tags=["Health"])
              async def read_root():
                  with tracer.start_as_current_span("root_endpoint"):
                      logging.info("Root endpoint accessed.")
                      return {"message": "Welcome to the Test API with Telemetry! Visit /docs for API documentation."}

              @app.get("/health", summary="Detailed Health Check", tags=["Health"])
              async def health_check(db_conn: asyncpg.Connection = Depends(get_db_connection)):
                  with tracer.start_as_current_span("health_check"):
                      logging.info("Health check endpoint accessed.")
                      try:
                          await db_conn.execute("SELECT 1")
                          return {"status": "ok", "database": "connected"}
                      except Exception as e:
                          logging.error(f"Database health check failed: {e}")
                          raise HTTPException(status_code=500, detail=f"Database connection failed: {e}")

              @app.post("/users", response_model=User, status_code=201, summary="Create a new user", tags=["Users"])
              async def create_user(user: UserCreate, db_conn: asyncpg.Connection = Depends(get_db_connection)):
                  with tracer.start_as_current_span("create_user"):
                      logging.info(f"Creating user: {user.email}")
                      try:
                          row = await db_conn.fetchrow(
                              "INSERT INTO users(name, email) VALUES($1, $2) RETURNING id, name, email",
                              user.name, user.email
                          )
                          return User.model_validate(row)
                      except asyncpg.exceptions.UniqueViolationError:
                          logging.warning(f"User with email {user.email} already exists.")
                          raise HTTPException(status_code=409, detail="User with this email already exists")
                      except Exception as e:
                          logging.error(f"Error creating user: {e}")
                          raise HTTPException(status_code=500, detail=f"Internal server error: {e}")

              @app.get("/users", response_model=List[User], summary="List all users", tags=["Users"])
              async def read_users(db_conn: asyncpg.Connection = Depends(get_db_connection)):
                  with tracer.start_as_current_span("list_users"):
                      logging.info("Fetching all users.")
                      rows = await db_conn.fetch("SELECT id, name, email FROM users")
                      return [User.model_validate(row) for row in rows]

              @app.get("/users/{user_id}", response_model=User, summary="Get a user by ID", tags=["Users"])
              async def read_user(user_id: int, db_conn: asyncpg.Connection = Depends(get_db_connection)):
                  with tracer.start_as_current_span("get_user"):
                      logging.info(f"Fetching user with ID: {user_id}")
                      row = await db_conn.fetchrow("SELECT id, name, email FROM users WHERE id = $1", user_id)
                      if row is None:
                          logging.warning(f"User with ID {user_id} not found.")
                          raise HTTPException(status_code=404, detail="User not found")
                      return User.model_validate(row)

              if __name__ == "__main__":
                  uvicorn.run("app:app", host="0.0.0.0", port=8000, reload=True)
              EOF
              python /tmp/app.py
          ports:
            - containerPort: 8000
          envFrom:
            - configMapRef:
                name: api-config
          resources:
            requests:
              cpu: "250m"
              memory: "256Mi"
            limits:
              cpu: "500m"
              memory: "512Mi"
          livenessProbe:
            httpGet:
              path: /health
              port: 8000
            initialDelaySeconds: 60
            periodSeconds: 10
            timeoutSeconds: 1
            failureThreshold: 3
          readinessProbe:
            httpGet:
              path: /health
              port: 8000
            initialDelaySeconds: 30
            periodSeconds: 5
            timeoutSeconds: 1
            failureThreshold: 3
---
apiVersion: v1
kind: Service
metadata:
  name: test-api-telemetry-service
  namespace: test-api
  labels:
    app: test-api-telemetry
spec:
  selector:
    app: test-api-telemetry
  ports:
    - protocol: TCP
      port: 8000
      targetPort: 8000
  type: ClusterIP
